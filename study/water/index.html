<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title></title>
</head>
<body>
    <canvas id="webgl" width="800" height="800" style="position:absolute;left:50%;margin-left:-400px;"></canvas>
</body>

<script src="../../lib/webgl-utils.js"></script>
<script src="../../lib/webgl-debug.js"></script>
<script src="../../lib/cuon-utils.js"></script>
<script src="../../lib/cuon-matrix.js"></script>
<script>

    var VSHADER_SOURCE =
        'const float PI = 3.141592653589793;\n' +
        'precision mediump float;\n' +
        'attribute vec4 a_Position;\n' +
        'attribute float a_angel;\n' +
        'uniform mat4 mvpMatrix;\n' +
        'attribute vec2 a_TexCoord;\n' +
        'varying vec2 v_TexCoord;\n' +
        'void main() {\n' +
        '  gl_Position =mvpMatrix* a_Position;\n' +
        '  v_TexCoord =a_TexCoord;\n' +
        '  gl_Position.y = gl_Position.y+ sin(a_angel*PI*0.1+((a_Position.x*2.1)+1.0))*0.2;\n' +
        ' gl_Position.y = gl_Position.y+(a_angel-a_angel);\n' +
        '  gl_PointSize = 2.0;\n' +
        '}\n';

    // Fragment shader program
    var FSHADER_SOURCE =
        '#ifdef GL_ES\n' +
        'precision mediump float;\n' +
        '#endif\n' +
        'uniform sampler2D u_Sampler;\n' +
        'varying vec2 v_TexCoord;\n' +
        'void main() {\n' +
        ' vec4 info = texture2D(u_Sampler, v_TexCoord);\n' +
        '  gl_FragColor =info;\n' +
        '}\n';

    var canvas = document.getElementById('webgl');
    // Get the rendering context for WebGL
    var gl = getWebGLContext(canvas);
    if (!gl) {
        console.log('Failed to get the rendering context for WebGL');
        // return;
    }
    // Initialize shaders
    if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) {
        console.log('Failed to intialize shaders.');
        //  return;
    }
    var a_Position = gl.getAttribLocation(gl.program, 'a_Position');
    if (a_Position < 0) {
        console.log('Failed to get the storage location of a_Position');
        //   return;
    }
    var a_TexCoord = gl.getAttribLocation(gl.program, 'a_TexCoord');
    if (a_TexCoord < 0) {
        console.log('Failed to get the storage location of a_TexCoord');
        //   return;
    }
    var a_angel = gl.getAttribLocation(gl.program, 'a_angel');
    if (a_angel < 0) {
        console.log('Failed to get the storage location of angel');
        //   return;

    }
    var mvpMatrix = gl.getUniformLocation(gl.program, 'mvpMatrix');
    if (mvpMatrix < 0) {
        console.log('Failed to get the storage location of mvpMatrix');
        //   return;

    }
    var u_Sampler = gl.getUniformLocation(gl.program, 'u_Sampler');
    if (u_Sampler < 0) {
        console.log('Failed to get the storage location of u_Sampler');
        //   return;

    }

    var texture = init_image();
    requestAnimationFrame(render);
    console.log(a_angel);
    function render() {

        gl.enableVertexAttribArray(a_Position);
        gl.enableVertexAttribArray(a_TexCoord);
         //gl.vertexAttribPointer(a_TexCoord, 2, gl.FLOAT, false, 0, 0);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        // Create a buffer object
        var vertexBuffer = gl.createBuffer();
        // Bind the buffer object to target
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        // Write date into the buffer object

        gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
        if (!vertexBuffer) {
            console.log('Failed to create the buffer object');
            return -1;
        }

        var coordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, coordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(coords_data), gl.STATIC_DRAW);
        if (!coordBuffer) {
            console.log('Failed to create the buffer object');
            return -1;
        }
    

        // // Bind the buffer object to target
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, coordBuffer);
        gl.vertexAttribPointer(a_TexCoord, 2, gl.FLOAT, false, 0, 0);

        //// Enable the assignment to a_Position variable
      






        // Specify the color for clearing <canvas>
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        angel += 0.1;
        // Clear <canvas>
    
        //gl.enableVertexAttribArray(a_TexCoord);
        // Enable the assignment to a_Position variable

       


        gl.uniformMatrix4fv(mvpMatrix, false, mvp_martrix.elements);
        gl.vertexAttrib1f(a_angel, angel);




        var points = 1;
        gl.drawArrays(points == 0 ? gl.POINTS : (points == 1 ? gl.TRIANGLES : (points == 2 ? gl.TRIANGLE_STRIP : gl.LINES)), 0, data.length / 2);
        requestAnimationFrame(render);
    }
    function init_image() {

        var texture = gl.createTexture();
        var image = new Image();
        image.src = './texture/timg.jpg';
        image.onload = function () {
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1); // Flip the image's y axis
            // Enable texture unit0
            gl.activeTexture(gl.TEXTURE0);
            // Bind the texture object to the target
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            // Set the texture parameters
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            // Set the texture image
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);

            // Set the texture unit 0 to the sampler
            gl.uniform1i(u_Sampler, 0);
        }
        return texture;
    }
    function compile(d) {

        var data = [];
        for (var i = 0; i < d.length; i++) {
            data.push(d[i][0], d[i][1]);
          
        }
  
        return new Float32Array(data);
    }
    function compile_triangles(d) {
       
        var data = [];
        var unique = [];
        for (var i = 0; i < d.length; i++) {
            
            add(d[i][0]);
            add(d[i][1]);
            add(d[i][2]);
        }
        function add(index) {
       
            var exist = false;
            //unique.forEach(function (v, k ){
            //    if (v == index) {
            //        exist = true;
                   
            //    }
            //});
            if (!exist) {
               unique.push(index);
                data.push(vertices[index][0], vertices[index][1]);
                coords_data.push(coords[index][0], coords[index][1]);
            }
        }
        console.log(data);
        return new Float32Array(data);
    }

    var vertices = [];
    var coords = [];
    var triangles = [];

    mesh();
    var coords_data = [];
    var data = compile_triangles(triangles);
    console.log(coords_data);
    var matrix = new Matrix4();
    matrix.setRotate(10, 1, 0, 0);
    var view_matrix = new Matrix4();
    view_matrix.setLookAt(0, 0,0.25, 0, 0,0,0,1,0);

    var mvp_martrix = view_matrix.multiply(matrix);
    var angel = 0.0;
    function mesh() {
        var detailX = 50, detailY = 50;
        for (var y = 0; y <= detailY ; y += 1) {
            var t = y / detailY ;
            for (var x = 0; x <= detailX; x += 1) {
                var s = x / detailX;
                vertices.push([2 * s - 1, 2 * t - 1]);
                coords.push([s, t]);
                if (x < detailX && y < detailY) {
                    var i = x + y * (detailX + 1);
                    triangles.push([i, i + 1, i + detailX + 1]);
                    triangles.push([i + detailX + 1, i + 1, i + detailX + 2 ]);
                }
            }
        }

    }

</script>
</html>